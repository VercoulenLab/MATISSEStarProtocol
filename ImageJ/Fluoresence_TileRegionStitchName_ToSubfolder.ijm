/* 
 * This script fetches information about tile regions from metadata generated by Zen software on export.
 * Information about region dimensions is used to guide MIST stitching
 * Tile region name is used for filename of output
 */

//for call by other macro
if (getArgument()!="") {
	directory = getArgument();
} else {
	print("\\Clear");
	directory = getDirectory("Choose a Directory");
}

setBatchMode(true);
overwrite = false;
overlap = 10;
prefix = File.getName(directory);

directory_EDF = directory + prefix + "_stacks/EDF/";
directory_stitches = File.getParent(File.getParent(directory)) + "/stitch/";
makeFolder(directory_stitches);
directory_stitches_prefix = directory_stitches + prefix + "/";
makeFolder(directory_stitches_prefix);

xml_meta_path = directory + prefix + "_meta.xml";
xml_meta = File.openAsString(xml_meta_path);
xml_meta_Name = fetchParameterXML(xml_meta, "SingleFileName");

Table.create("TileRegions");

// Scene information
xml_meta_Scenes = fetchParameterXML(xml_meta, "Scenes");
xml_meta_Scenes_replaced = replace(xml_meta_Scenes, "<Scene Index=", "#");
xml_meta_Scenes_replaced_parts = split(xml_meta_Scenes_replaced, "#");
for (i = 1; i < xml_meta_Scenes_replaced_parts.length; i++) {
	string = xml_meta_Scenes_replaced_parts[i];
	Index = substring(string, 1, indexOf(string, " Name=")-1);
	Table.set("Index", i-1, Index); 
	// ! potentially Scene index starts at 1
	Name = substring(string, indexOfEnd(string, " Name=")+1, indexOf(string, ">")-1);
	Table.set("Name", i-1, Name);	
	RegionId = fetchParameterXML(string, "RegionId");
	Table.set("RegionId", i-1, RegionId);
}

// Tile region information
xml_meta_TileRegions = fetchParameterXML(xml_meta, "TileRegions");
xml_meta_TileRegions_replaced = replace(xml_meta_TileRegions, "<TileRegion Name=", "#");
xml_meta_TileRegions_replaced_parts = split(xml_meta_TileRegions_replaced, "#");
for (i = 1; i < xml_meta_TileRegions_replaced_parts.length; i++) {
	string = xml_meta_TileRegions_replaced_parts[i];
	RegionId = substring(string, indexOfEnd(string, "Id=")+1, indexOf(string, ">")-1);
	Columns = fetchParameterXML(string, "Columns");
	Rows = fetchParameterXML(string, "Rows");
	
	// find match and add data
	for (i_Table = 0; i_Table < Table.size; i_Table++) {
		entry_Table_RegionId = Table.getString("RegionId", i_Table);
		if (entry_Table_RegionId == RegionId) {
			Table.set("Columns", i_Table, Columns);
			Table.set("Rows", i_Table, Rows);
		}
	}
}

Table.update;

// Channel information
xml_meta_Channels = fetchParameterXML(xml_meta, "SubDimensionSetups");
xml_meta_Channels = substring(xml_meta_Channels, 0, lastIndexOf(xml_meta_Channels, "</Track>"));
xml_meta_Channels_replaced = replace(xml_meta_Channels, "<Track ", "%");
xml_meta_Channels_replaced_parts = split(xml_meta_Channels_replaced, "%");

Channel_count = 0;
for (i = 1; i < xml_meta_Channels_replaced_parts.length; i++) {
	string = xml_meta_Channels_replaced_parts[i];
	Channel_status = substring(string, indexOfEnd(string, "IsActivated=")+1, indexOf(string, "IsSelected")-2);
	if (Channel_status){
		Channel_count++;
	}
}

// for all tileregions execute stitching
if (File.exists(directory_EDF)) {
	directory_EDF_filelist = getFileList(directory_EDF);
	for (i_S = 0; i_S < Table.size; i_S++) {
		Name = Table.getString("Name", i_S);
		Index = parseInt(Table.get("Index", i_S));
		Columns = Table.get("Columns", i_S);
		Rows = Table.get("Rows", i_S);
		
		for (i_C = 0; i_C < Channel_count; i_C++) {
			pattern = prefix + "_S" + Index + 1 + "_C" + i_C + 1 + "_M{ppp}_EDF.tiff";
			// check if all expected files are present, will only check first and last!
			path_first = directory_EDF + prefix + "_S" + Index + 1 + "_C" + i_C + 1 + "_M001_EDF.tiff";
			path_last = directory_EDF + prefix + "_S" + Index + 1 + "_C" + i_C + 1 + "_M" + leading_zero(Columns * Rows, 100) + "_EDF.tiff";
			// ! need to implement recycling of tile-positions from first channel stitch to others
			if (File.exists(path_first) && File.exists(path_last)) {
				print("Will now stitch: " + Name + ", " + i_S + 1 + " of: " + Table.size);
				print(path_first);
				Name_Stitch = xml_meta_Name + "_" + Name + "_C" + i_C + 1 + "_";
				path_output_expected = directory_stitches_prefix + Name_Stitch + "stitched-0.tif";
				if (! File.exists(path_output_expected) || overwrite) {
					tileStitchMIST(directory_EDF, directory_stitches_prefix, overlap, Name_Stitch, pattern, Columns, Rows);
				} else {
					print("output exists, will not overwrite");
				}
			}
		}
	}
}
print("DONE");

function tileStitchMIST(path_images, path_output, overlap, name_output, pattern, Columns, Rows) { 
	run("MIST", "gridwidth=["+Columns+"] gridheight=["+Rows+"] starttile=1 imagedir=["+path_images+"] filenamepattern=["+pattern+"] filenamepatterntype=SEQUENTIAL gridorigin=UL assemblefrommetadata=false globalpositionsfile=[] numberingpattern=HORIZONTALCONTINUOUS startrow=0 startcol=0 extentwidth=["+Columns+"] extentheight=["+Rows+"] timeslices=0 istimeslicesenabled=false outputpath=["+path_output+"] displaystitching=false outputfullimage=true outputmeta=true outputimgpyramid=false blendingmode=LINEAR blendingalpha=NaN outfileprefix=["+name_output+"] programtype=AUTO numcputhreads=10 loadfftwplan=false savefftwplan=false fftwplantype=MEASURE fftwlibraryname=libfftw3 fftwlibraryfilename=libfftw3.dll stagerepeatability=0 horizontaloverlap=10.0 verticaloverlap=10.0 numfftpeaks=0 overlapuncertainty=NaN isusedoubleprecision=false isusebioformats=false issuppressmodelwarningdialog=false isenablecudaexceptions=false translationrefinementmethod=SINGLE_HILL_CLIMB numtranslationrefinementstartpoints=16 headless=false loglevel=MANDATORY debuglevel=NONE");
	// clean leftover ram
	run("Collect Garbage");
	call("java.lang.System.gc");
	if (isOpen("Exception")){
		selectWindow("Exception");
		run("Close");
	}
}

function indexOfEnd(string, subString) { 
	index = indexOf(string, subString) + lengthOf(subString);
	return index;
}

function fetchParameterXML(string, name) {
	delimeter_start = "<" + name + ">";
	delimeter_end = "</" + name + ">";
	
	output = substring(string, indexOfEnd(string, delimeter_start), indexOf(string, delimeter_end));
	return output;
}

function makeFolder(path) {
	if (!File.exists(path)) {
		File.makeDirectory(path);
	}
}

function leading_zero(x, maxx) {
	if (maxx < 100) {
		if (maxx < 10) {
			fx = x;
		} else {
			if (x < 10) {
				fx = "0" + x;
			} else {
				fx = x;
			}
		}
	} else {
		if (x < 100) {
			if (x < 10) {
				fx = "00" + x;
			} else {
				fx = "0" + x;
			}
		} else {
			fx = x;
		}
	}
	return fx;
}